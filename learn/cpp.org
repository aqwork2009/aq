** knowleage 


zhongjianjian
ZeroMQ、Kafka、Infomatica、Tibco


Mysql/MangoDB等数据库开发；熟悉Redis，Nginx


分布式系统架构:
SOA、微服务等g


1.PoW，PoS，DPoS，PBFT，Paxos，Raft 等；
2. Bitcoin，Ethereum，Hyperledger 
3、熟悉数据结构和算法，对密码学，安全协议和加密算法有研究；
4、有分布式，点对点网络协议或应用开发经验优先；


1、 本科及以上学历，5年以上技术开发经验，有2年以上团队管理经验。
2、 有高并发互联网应用架构优化的经验者优先。
3、 熟悉mysql，memcache，redis，zookeeper，hive，hbase等开源组件的工作原理和适用场景。
4、熟练掌握C++，熟悉面向对象编程，对算法设计/数据结构有深刻的理解。
5、熟悉网络协议，精通网络编程、多线程编程技术，具备高并发网络服务开发经验。

熟练使用逆向工具及框架，如：Apktool、dex2jar、IDA、JEB、Frida、Xposed等；
image tech
OSG, 

1、负责软件开发和维护，包括软件设计、实现、测试、集成/发布和错误修复。
2、参与需求分析，并支持产品所有者和软件架构师对解决方案和架构进行分析。
3、包括任务分解、工作量估算和计划、实施、测试、演示和DOD。
4、确保软件代码的质量、可测试性、可维护性和功能可用性。

1、计算机、信息技术或相关领域本科或硕士学历
2、精通C++编程语言，熟悉Linux平台。熟悉NoDE.js，Python，有Linux /UNIX多线程编程经验，网络编程包括异步IO（EPOLL等）优先。
3、熟悉面向对象分析和设计，精通OOA/D，精通UML和设计模式；
4、熟悉业务建模（SAA首选）
5、熟悉SQL或NoSQL数据库；
6、熟悉GIT/Mag file；
7、了解HTTP/HTTPS；了解在REST API /JSON/直径/RADIUS /EAP-AKA知识；了解KVM虚拟化和云环境原理及应用；
8、良好的团队合作精神和强烈的团队精神；
9、良好的英语写作能力，能用英语进行非复杂技术的讨论。 

stl
https://blog.csdn.net/longhuahaha/article/details/8365041



** auto makefile
Makefile 文件自动生成方法
转载 2018年01月15日 10:06:35

    标签：
    Makefile /
    自动生成

 在本文中，将给大家介绍如何使用 autoconf和automake两个工具来帮助我们自动地生成符合自由软件惯例的Makefile，这样就可以象常见的GNU程序一样，只要使用“./configure”，“make”，“make install”就可以把程序安装到Linux系统中去了。
编译一个简单的源文件main.c,需要自动生成一个Makefile。

以下是步骤：

第一步：

在某个目录下创建一个文件main.c,其内容如下：

------------------------------------------------

#include <stdio.h>

int main(int argc, char** argv)

{

    printf("Hello, Auto Makefile!\n");

    return 0;

}

------------------------------------------------

第二步：

运行 autoscan , 自动创建两个文件： autoscan.log configure.scan

此时状态如下：

[root@localhost main]# autoscan

[root@localhost main]# ls

autoscan.log configure.scan main.c

[root@localhost main]#

第三步：

修改configure.scan的文件名为configure.in

查看configure.in的内容：

#                                               -*- Autoconf -*-

# Process this file with autoconf to produce a configure script.

AC_PREREQ(2.61)

AC_INIT(FULL-PACKAGE-NAME, VERSION, BUG-REPORT-ADDRESS)

AC_CONFIG_SRCDIR([main.c])

AC_CONFIG_HEADER([config.h])

# Checks for programs.

AC_PROG_CC

# Checks for libraries.

# Checks for header files.

# Checks for typedefs, structures, and compiler characteristics.

# Checks for library functions.

AC_OUTPUT

------------------------------------------------

解读以上的文件：

------------------------------------------------

#                                               -*- Autoconf -*-

# Process this file with autoconf to produce a configure script.

# AC_PREREQ:

# 确保使用的是足够新的Autoconf版本。如果用于创建configure的Autoconf的版

# 本比version 要早，就在标准错误输出打印一条错误消息并不会创建configure。

AC_PREREQ(2.61)

# 初始化,定义软件的基本信息,包括设置包的全称,版本号以及报告BUG时需要用的邮箱地址

AC_INIT(FULL-PACKAGE-NAME, VERSION, BUG-REPORT-ADDRESS)

# 用来侦测所指定的源码文件是否存在，来确定源码目录的有效性

AC_CONFIG_SRCDIR([main.c])

# 用于生成config.h文件，以便autoheader使用

AC_CONFIG_HEADER([config.h])

# Checks for programs.

AC_PROG_CC

# Checks for libraries.

# Checks for header files.

# Checks for typedefs, structures, and compiler characteristics.

# Checks for library functions.

# 创建输出文件。在`configure.in'的末尾调用本宏一次。

AC_OUTPUT

------------------------------------------------

修改动作:

    1.修改AC_INIT里面的参数: AC_INIT(main,1.0, szgdagun@sohu.com)

    2.添加宏AM_INIT_AUTOMAKE, 它是automake所必备的宏，也同前面一样，PACKAGE是所要产生软件套件的名称，VERSION是版本编号。

    3.在AC_OUTPUT后添加输出文件Makefile

修改后的结果:

#                                               -*- Autoconf -*-

# Process this file with autoconf to produce a configure script.

AC_PREREQ(2.61)

AC_INIT(main, 1.0, pgpxc@163.com)   //修改

AC_CONFIG_SRCDIR([main.c])

AC_CONFIG_HEADER([config.h])

AM_INIT_AUTOMAKE(main,1.0)  //新增

# Checks for programs.

AC_PROG_CC

# Checks for libraries.

# Checks for header files.

# Checks for typedefs, structures, and compiler characteristics.

# Checks for library functions.

AC_CONFIG_FILES([Makefile]) //如果有，就不需要增加

AC_OUTPUT

------------------------------------------------

第四步:

运行 aclocal, 生成一个“aclocal.m4”文件和一个缓冲文件夹autom4te.cache，该文件主要处理本地的宏定义。

此时的状态是：

[root@localhost main]# aclocal

[root@localhost main]# ls

aclocal.m4 autom4te.cache autoscan.log configure.in configure.in~ main.c

[root@localhost main]#

第五步：

运行 autoconf, 目的是生成 configure

此时的状态是：

[root@localhost main]# autoconf
[root@localhost main]# ls

aclocal.m4      autoscan.log configure.in   main.c

autom4te.cache configure     configure.in~

[root@localhost main]#

第六步：

运行 autoheader，它负责生成config.h.in文件。该工具通常会从“acconfig.h”文件中复制用户附加的符号定义，因此此处没有附加符号定义，所以不需要创建“acconfig.h”文件。

此时的状态是：

[root@localhost main]# autoheader

[root@localhost main]# ls

aclocal.m4      autoscan.log configure     configure.in~

autom4te.cache config.h.in   configure.in main.c

[root@localhost main]#

第七步：

将运行 automake, 但在此之前应该做一下准备工作!

首先

创建一个 Makefile.am.这一步是创建Makefile很重要的一步，automake要用的脚本配置文件是Makefile.am，用户需要自己创建相应的文件。之后，automake工具转换成Makefile.in。

这个Makefile.am的内容如下：

------------------------------------------------

AUTOMAKE_OPTIONS=foreign

bin_PROGRAMS=main

main_SOURCES=main.c

------------------------------------------------

下面对该脚本文件的对应项进行解释。

      其中的AUTOMAKE_OPTIONS为设置automake的选项。由于GNU（在第1章中已经有所介绍）对自己发布的软件有严格的规范，比如必须附 带许可证声明文件COPYING等，否则automake执行时会报错。automake提供了三种软件等级：foreign、gnu和gnits，让用 户选择采用，默认等级为gnu。在本例使用foreign等级，它只检测必须的文件。

bin_PROGRAMS定义要产生的执行文件名。如果要产生多个执行文件，每个文件名用空格隔开。

 main_SOURCES定义“main”这个执行程序所需要的原始文件。如果”main”这个程序是由多个原始文件所产生的，则必须把它所用到的所有原 始文件都列出来，并用空格隔开。例如：若目标体“main”需要“main.c”、“sunq.c”、“main.h”三个依赖文件，则定义 main_SOURCES=main.c sunq.c main.h。要注意的是，如果要定义多个执行文件，则对每个执行程序都要定义相应的file_SOURCES。

其次

使用automake对其生成“configure.in”文件，在这里使用选项“—adding-missing”可以让automake自动添加有一些必需的脚本文件。

运行后的状态是：

------------------------------------------------

[root@localhost main]# automake --add-missing

configure.in:8: installing `./missing'

configure.in:8: installing `./install-sh'

Makefile.am: installing `./depcomp'

[root@localhost main]# ls

aclocal.m4      config.h.in   configure.in~ main.c        Makefile.in

autom4te.cache configure     depcomp        Makefile.am missing

autoscan.log    configure.in install-sh     Makefile.am~

[root@localhost main]#

------------------------------------------------

第八步

运行configure，在这一步中，通过运行自动配置设置文件configure，把Makefile.in变成了最终的Makefile。

运行的结果如下：

------------------------------------------------

[root@localhost main]# ./configure

checking for a BSD-compatible install... /usr/bin/install -c

checking whether build environment is sane... yes

checking for a thread-safe mkdir -p... /bin/mkdir -p

checking for gawk... gawk

checking whether make sets $(MAKE)... yes

checking for gcc... gcc

checking for C compiler default output file name... a.out

checking whether the C compiler works... yes

checking whether we are cross compiling... no

checking for suffix of executables...

checking for suffix of object files... o

checking whether we are using the GNU C compiler... yes

checking whether gcc accepts -g... yes

checking for gcc option to accept ISO C89... none needed

checking for style of include used by make... GNU

checking dependency style of gcc... gcc3

configure: creating ./config.status

config.status: creating Makefile

config.status: creating config.h

config.status: executing depfiles commands

[root@localhost main]# ls

aclocal.m4      config.h.in    configure.in   main.c        Makefile.in

autom4te.cache config.log     configure.in~ Makefile      missing

autoscan.log    config.status depcomp        Makefile.am   stamp-h1

config.h        configure      install-sh     Makefile.am~

[root@localhost main]#

------------------------------------------------

第九步

运行 make，对配置文件Makefile进行测试一下

此时的状态如下:

------------------------------------------------

[root@localhost main]# make

cd . && /bin/sh /root/project/main/missing --run aclocal-1.10

cd . && /bin/sh /root/project/main/missing --run automake-1.10 --foreign

cd . && /bin/sh /root/project/main/missing --run autoconf

/bin/sh ./config.status --recheck

running CONFIG_SHELL=/bin/sh /bin/sh ./configure   --no-create --no-recursion

checking for a BSD-compatible install... /usr/bin/install -c

checking whether build environment is sane... yes

checking for a thread-safe mkdir -p... /bin/mkdir -p

checking for gawk... gawk

checking whether make sets $(MAKE)... yes

checking for gcc... gcc

checking for C compiler default output file name... a.out

checking whether the C compiler works... yes

checking whether we are cross compiling... no

checking for suffix of executables...

checking for suffix of object files... o

checking whether we are using the GNU C compiler... yes

checking whether gcc accepts -g... yes

checking for gcc option to accept ISO C89... none needed

checking for style of include used by make... GNU

checking dependency style of gcc... gcc3

configure: creating ./config.status

/bin/sh ./config.status

config.status: creating Makefile

config.status: creating config.h

config.status: config.h is unchanged

config.status: executing depfiles commands

cd . && /bin/sh /root/project/main/missing --run autoheader

rm -f stamp-h1

touch config.h.in

make all-am

make[1]: Entering directory `/root/project/main'

gcc -DHAVE_CONFIG_H -I.     -g -O2 -MT main.o -MD -MP -MF .deps/main.Tpo -c -o main.o main.c

mv -f .deps/main.Tpo .deps/main.Po

gcc -g -O2   -o main main.o

cd . && /bin/sh ./config.status config.h

config.status: creating config.h

config.status: config.h is unchanged

make[1]: Leaving directory `/root/project/main'

[root@localhost main]# ls

aclocal.m4      autoscan.log config.h.in config.status configure.in   depcomp     main    main.o    Makefile.am   Makefile.in stamp-h1

autom4te.cache config.h      config.log   configure      configure.in~ install-sh main.c Makefile Makefile.am~ missing

[root@localhost main]#

------------------------------------------------

第十步

运行生成的文件 main：

------------------------------------------------

[root@localhost main]# ./main

Hello, Auto Makefile!



** stl container

STL容器效率比较

1、vector

变长一维数组，连续存放的内存块，有保留内存，堆中分配内存；

支持[]操作，高效率的随机访问；

在最后增加元素时，一般不需要分配内存空间，速度快；在中间或开始操作元素时要进行内存拷贝效率低；

vector高效的原因在于配置了比其所容纳的元素更多的内存，内存重新配置会花很多时间；

注：需要高效的随即存取，而不在乎插入和删除使用vector。

 

2、list

双向链表，内存空间上可能是不连续的，无保留内存，堆中分配内存；

不支持随机存取，开始和结尾元素的访问时间快,其它元素都O（n）；

在任何位置安插和删除元素速度都比较快，安插和删除操作不会使其他元素的各个pointer，reference，iterator失效；

注：大量的插入和删除，而不关系随即存取使用list。

 

3、deque

双端队列，在堆上分配内存，一个堆保存几个元素，而堆之间使用指针连接；

支持[]操作，在首端和末端插入和删除元素比较快，在中部插入和删除则比较慢，像是list和vector的结合；

注：关心插入和删除并关心随即存取折中使用deque。

 

4、set&multiset

有序集合，使用平衡二叉树存储，按照给定的排序规则（默认按less排序）对set中的数据进行排序；

set中不允许有重复元素，multiset中运行有重复元素；

两者不支持直接存取元素的操作；

因为是自动排序，查找元素速度比较快；
不能直接改变元素值，否则会打乱原本正确的顺序，必须先下删除旧元素，再插入新的元素。

 

5、map&multimap

字典库，一个值映射成另一个值，使用平衡二叉树存储，按照给定的排序规则对map中的key值进行排序；

map中的key值不允许重复，multimap中的key允许重复；

根据已知的key值查找元素比较快；

插入和删除操作比较慢。


** linked
dynamic
LIBS += library.dll

简单的写法是上面的样子，建议使用完整的写法：

LIBS += -LD:/my_program_design/dll_test/test_library_by_header/ -llibrary


static 在pro文件增加：
LIBS += -LD:/my_program_design/dll_test/test_static_library/ -llibstatic_library



** compile item
https://blog.csdn.net/nickwong_/article/details/38762611

-fPIC 作用于编译阶段，告诉编译器产生与位置无关代码(Position-Independent Code)，
  则产生的代码中，没有绝对地址，全部使用相对地址，故而代码可以被加载器加载到内存的任意
  位置，都可以正确的执行。这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的。


    -I /home/hello/include，表示将/home/hello/include目录作为第一个寻找头文件的目录，寻找的顺序是：/home/hello/include–>/usr/include–>/usr/local/include
        也就是指定优先查找的目录，找不到的话查找默认目录

    -L /home/hello/lib，表示将/home/hello/lib目录作为第一个寻找库文件的目录， 寻找的顺序是：/home/hello/lib–>/lib–>/usr/lib–>/usr/local/lib
        同上，也是指定优先查找的目录

    -l word , 表示**寻找动态链接库文件**libword.so（也就是文件名去掉前缀和后缀所代表的库文件)
        如果 加上编译选项-static，表示寻找静态链接库文件，也就是libword.a
今天在看一个makefile时看到了gcc -W -Wall....这句，不明其理，专门查看了gcc的使用手册。

-w的意思是关闭编译时的警告，也就是编译后不显示任何warning，因为有时在编译之后编译器会显示一些例如数据转换之类的警告，这些警告是我们平时可以忽略的。

-Wall选项意思是编译后显示所有警告。

-W选项类似-Wall，会显示警告，但是只显示编译器认为会出现错误的警告。

*** -fPIC
-fPIC 作用于编译阶段，告诉编译器产生与位置无关代码(Position-Independent Code)，
  则产生的代码中，没有绝对地址，全部使用相对地址，故而代码可以被加载器加载到内存的任意
  位置，都可以正确的执行。这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的。

gcc -shared -fPIC -o 1.so 1.c
这里有一个-fPIC参数
PIC就是position independent code
PIC使.so文件的代码段变为真正意义上的共享
如果不加-fPIC,则加载.so文件的代码段时,代码段引用的数据对象需要重定位, 重定位会修改代码段的内容,这就造成每个使用这个.so文件代码段的进程在内核里都会生成这个.so文件代码段的copy.每个copy都不一样,取决于 这个.so文件代码段和数据段内存映射的位置.
** debug
查看依赖搜索：ldd xxxx
