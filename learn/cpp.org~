** knowleage 

zhongjianjian
ZeroMQ、Kafka、Infomatica、Tibco


Mysql/MangoDB等数据库开发；熟悉Redis，Nginx



qu kuai lian
1.PoW，PoS，DPoS，PBFT，Paxos，Raft 等；
2. Bitcoin，Ethereum，Hyperledger 
3、熟悉数据结构和算法，对密码学，安全协议和加密算法有研究；
4、有分布式，点对点网络协议或应用开发经验优先；



stl
https://blog.csdn.net/longhuahaha/article/details/8365041

** auto makefile
Makefile 文件自动生成方法
转载 2018年01月15日 10:06:35

    标签：
    Makefile /
    自动生成

 在本文中，将给大家介绍如何使用 autoconf和automake两个工具来帮助我们自动地生成符合自由软件惯例的Makefile，这样就可以象常见的GNU程序一样，只要使用“./configure”，“make”，“make install”就可以把程序安装到Linux系统中去了。

编译一个简单的源文件main.c,需要自动生成一个Makefile。

以下是步骤：

第一步：

在某个目录下创建一个文件main.c,其内容如下：

------------------------------------------------

#include <stdio.h>

int main(int argc, char** argv)

{

    printf("Hello, Auto Makefile!\n");

    return 0;

}

------------------------------------------------

第二步：

运行 autoscan , 自动创建两个文件： autoscan.log configure.scan

此时状态如下：

[root@localhost main]# autoscan

[root@localhost main]# ls

autoscan.log configure.scan main.c

[root@localhost main]#

第三步：

修改configure.scan的文件名为configure.in

查看configure.in的内容：

#                                               -*- Autoconf -*-

# Process this file with autoconf to produce a configure script.

AC_PREREQ(2.61)

AC_INIT(FULL-PACKAGE-NAME, VERSION, BUG-REPORT-ADDRESS)

AC_CONFIG_SRCDIR([main.c])

AC_CONFIG_HEADER([config.h])

# Checks for programs.

AC_PROG_CC

# Checks for libraries.

# Checks for header files.

# Checks for typedefs, structures, and compiler characteristics.

# Checks for library functions.

AC_OUTPUT

------------------------------------------------

解读以上的文件：

------------------------------------------------

#                                               -*- Autoconf -*-

# Process this file with autoconf to produce a configure script.

# AC_PREREQ:

# 确保使用的是足够新的Autoconf版本。如果用于创建configure的Autoconf的版

# 本比version 要早，就在标准错误输出打印一条错误消息并不会创建configure。

AC_PREREQ(2.61)

# 初始化,定义软件的基本信息,包括设置包的全称,版本号以及报告BUG时需要用的邮箱地址

AC_INIT(FULL-PACKAGE-NAME, VERSION, BUG-REPORT-ADDRESS)

# 用来侦测所指定的源码文件是否存在，来确定源码目录的有效性

AC_CONFIG_SRCDIR([main.c])

# 用于生成config.h文件，以便autoheader使用

AC_CONFIG_HEADER([config.h])

# Checks for programs.

AC_PROG_CC

# Checks for libraries.

# Checks for header files.

# Checks for typedefs, structures, and compiler characteristics.

# Checks for library functions.

# 创建输出文件。在`configure.in'的末尾调用本宏一次。

AC_OUTPUT

------------------------------------------------

修改动作:

    1.修改AC_INIT里面的参数: AC_INIT(main,1.0, szgdagun@sohu.com)

    2.添加宏AM_INIT_AUTOMAKE, 它是automake所必备的宏，也同前面一样，PACKAGE是所要产生软件套件的名称，VERSION是版本编号。

    3.在AC_OUTPUT后添加输出文件Makefile

修改后的结果:

#                                               -*- Autoconf -*-

# Process this file with autoconf to produce a configure script.

AC_PREREQ(2.61)

AC_INIT(main, 1.0, pgpxc@163.com)   //修改

AC_CONFIG_SRCDIR([main.c])

AC_CONFIG_HEADER([config.h])

AM_INIT_AUTOMAKE(main,1.0)  //新增

# Checks for programs.

AC_PROG_CC

# Checks for libraries.

# Checks for header files.

# Checks for typedefs, structures, and compiler characteristics.

# Checks for library functions.

AC_CONFIG_FILES([Makefile]) //如果有，就不需要增加

AC_OUTPUT

------------------------------------------------

第四步:

运行 aclocal, 生成一个“aclocal.m4”文件和一个缓冲文件夹autom4te.cache，该文件主要处理本地的宏定义。

此时的状态是：

[root@localhost main]# aclocal

[root@localhost main]# ls

aclocal.m4 autom4te.cache autoscan.log configure.in configure.in~ main.c

[root@localhost main]#

第五步：

运行 autoconf, 目的是生成 configure

此时的状态是：

[root@localhost main]# autoconf

[root@localhost main]# ls

aclocal.m4      autoscan.log configure.in   main.c

autom4te.cache configure     configure.in~

[root@localhost main]#

第六步：

运行 autoheader，它负责生成config.h.in文件。该工具通常会从“acconfig.h”文件中复制用户附加的符号定义，因此此处没有附加符号定义，所以不需要创建“acconfig.h”文件。

此时的状态是：

[root@localhost main]# autoheader

[root@localhost main]# ls

aclocal.m4      autoscan.log configure     configure.in~

autom4te.cache config.h.in   configure.in main.c

[root@localhost main]#

第七步：

将运行 automake, 但在此之前应该做一下准备工作!

首先

创建一个 Makefile.am.这一步是创建Makefile很重要的一步，automake要用的脚本配置文件是Makefile.am，用户需要自己创建相应的文件。之后，automake工具转换成Makefile.in。

这个Makefile.am的内容如下：

------------------------------------------------

AUTOMAKE_OPTIONS=foreign

bin_PROGRAMS=main

main_SOURCES=main.c

------------------------------------------------

下面对该脚本文件的对应项进行解释。

      其中的AUTOMAKE_OPTIONS为设置automake的选项。由于GNU（在第1章中已经有所介绍）对自己发布的软件有严格的规范，比如必须附 带许可证声明文件COPYING等，否则automake执行时会报错。automake提供了三种软件等级：foreign、gnu和gnits，让用 户选择采用，默认等级为gnu。在本例使用foreign等级，它只检测必须的文件。

bin_PROGRAMS定义要产生的执行文件名。如果要产生多个执行文件，每个文件名用空格隔开。

 main_SOURCES定义“main”这个执行程序所需要的原始文件。如果”main”这个程序是由多个原始文件所产生的，则必须把它所用到的所有原 始文件都列出来，并用空格隔开。例如：若目标体“main”需要“main.c”、“sunq.c”、“main.h”三个依赖文件，则定义 main_SOURCES=main.c sunq.c main.h。要注意的是，如果要定义多个执行文件，则对每个执行程序都要定义相应的file_SOURCES。

其次

使用automake对其生成“configure.in”文件，在这里使用选项“—adding-missing”可以让automake自动添加有一些必需的脚本文件。

运行后的状态是：

------------------------------------------------

[root@localhost main]# automake --add-missing

configure.in:8: installing `./missing'

configure.in:8: installing `./install-sh'

Makefile.am: installing `./depcomp'

[root@localhost main]# ls

aclocal.m4      config.h.in   configure.in~ main.c        Makefile.in

autom4te.cache configure     depcomp        Makefile.am missing

autoscan.log    configure.in install-sh     Makefile.am~

[root@localhost main]#

------------------------------------------------

第八步

运行configure，在这一步中，通过运行自动配置设置文件configure，把Makefile.in变成了最终的Makefile。

运行的结果如下：

------------------------------------------------

[root@localhost main]# ./configure

checking for a BSD-compatible install... /usr/bin/install -c

checking whether build environment is sane... yes

checking for a thread-safe mkdir -p... /bin/mkdir -p

checking for gawk... gawk

checking whether make sets $(MAKE)... yes

checking for gcc... gcc

checking for C compiler default output file name... a.out

checking whether the C compiler works... yes

checking whether we are cross compiling... no

checking for suffix of executables...

checking for suffix of object files... o

checking whether we are using the GNU C compiler... yes

checking whether gcc accepts -g... yes

checking for gcc option to accept ISO C89... none needed

checking for style of include used by make... GNU

checking dependency style of gcc... gcc3

configure: creating ./config.status

config.status: creating Makefile

config.status: creating config.h

config.status: executing depfiles commands

[root@localhost main]# ls

aclocal.m4      config.h.in    configure.in   main.c        Makefile.in

autom4te.cache config.log     configure.in~ Makefile      missing

autoscan.log    config.status depcomp        Makefile.am   stamp-h1

config.h        configure      install-sh     Makefile.am~

[root@localhost main]#

------------------------------------------------

第九步

运行 make，对配置文件Makefile进行测试一下

此时的状态如下:

------------------------------------------------

[root@localhost main]# make

cd . && /bin/sh /root/project/main/missing --run aclocal-1.10

cd . && /bin/sh /root/project/main/missing --run automake-1.10 --foreign

cd . && /bin/sh /root/project/main/missing --run autoconf

/bin/sh ./config.status --recheck

running CONFIG_SHELL=/bin/sh /bin/sh ./configure   --no-create --no-recursion

checking for a BSD-compatible install... /usr/bin/install -c

checking whether build environment is sane... yes

checking for a thread-safe mkdir -p... /bin/mkdir -p

checking for gawk... gawk

checking whether make sets $(MAKE)... yes

checking for gcc... gcc

checking for C compiler default output file name... a.out

checking whether the C compiler works... yes

checking whether we are cross compiling... no

checking for suffix of executables...

checking for suffix of object files... o

checking whether we are using the GNU C compiler... yes

checking whether gcc accepts -g... yes

checking for gcc option to accept ISO C89... none needed

checking for style of include used by make... GNU

checking dependency style of gcc... gcc3

configure: creating ./config.status

/bin/sh ./config.status

config.status: creating Makefile

config.status: creating config.h

config.status: config.h is unchanged

config.status: executing depfiles commands

cd . && /bin/sh /root/project/main/missing --run autoheader

rm -f stamp-h1

touch config.h.in

make all-am

make[1]: Entering directory `/root/project/main'

gcc -DHAVE_CONFIG_H -I.     -g -O2 -MT main.o -MD -MP -MF .deps/main.Tpo -c -o main.o main.c

mv -f .deps/main.Tpo .deps/main.Po

gcc -g -O2   -o main main.o

cd . && /bin/sh ./config.status config.h

config.status: creating config.h

config.status: config.h is unchanged

make[1]: Leaving directory `/root/project/main'

[root@localhost main]# ls

aclocal.m4      autoscan.log config.h.in config.status configure.in   depcomp     main    main.o    Makefile.am   Makefile.in stamp-h1

autom4te.cache config.h      config.log   configure      configure.in~ install-sh main.c Makefile Makefile.am~ missing

[root@localhost main]#

------------------------------------------------

第十步

运行生成的文件 main：

------------------------------------------------

[root@localhost main]# ./main

Hello, Auto Makefile!



** stl container

STL容器效率比较

1、vector

变长一维数组，连续存放的内存块，有保留内存，堆中分配内存；

支持[]操作，高效率的随机访问；

在最后增加元素时，一般不需要分配内存空间，速度快；在中间或开始操作元素时要进行内存拷贝效率低；

vector高效的原因在于配置了比其所容纳的元素更多的内存，内存重新配置会花很多时间；

注：需要高效的随即存取，而不在乎插入和删除使用vector。

 

2、list

双向链表，内存空间上可能是不连续的，无保留内存，堆中分配内存；

不支持随机存取，开始和结尾元素的访问时间快,其它元素都O（n）；

在任何位置安插和删除元素速度都比较快，安插和删除操作不会使其他元素的各个pointer，reference，iterator失效；

注：大量的插入和删除，而不关系随即存取使用list。

 

3、deque

双端队列，在堆上分配内存，一个堆保存几个元素，而堆之间使用指针连接；

支持[]操作，在首端和末端插入和删除元素比较快，在中部插入和删除则比较慢，像是list和vector的结合；

注：关心插入和删除并关心随即存取折中使用deque。

 

4、set&multiset

有序集合，使用平衡二叉树存储，按照给定的排序规则（默认按less排序）对set中的数据进行排序；

set中不允许有重复元素，multiset中运行有重复元素；

两者不支持直接存取元素的操作；

因为是自动排序，查找元素速度比较快；
不能直接改变元素值，否则会打乱原本正确的顺序，必须先下删除旧元素，再插入新的元素。

 

5、map&multimap

字典库，一个值映射成另一个值，使用平衡二叉树存储，按照给定的排序规则对map中的key值进行排序；

map中的key值不允许重复，multimap中的key允许重复；

根据已知的key值查找元素比较快；

插入和删除操作比较慢。


** 负责WPS客户端架构
调优，性能优化；
岗位要求：
1.熟练掌握C++语言，熟练使用C++标准库或相关架构；
2.有深入研究实现过具备实际用途的代码库并应用于生产环境；
3.4年以上互联网应用开发经验；
4.熟悉常见软件架构，主导或深入参与过一个软件的架构设计和实现；
5.有软件性能优化相关工作经验；
6.具体复杂软件（代码量巨大、业务多）驾驭能力，有软件重构的实际经验；
7.掌握Windows系统编程，熟悉win32api；
8.熟悉Qt者优先。 


** c++工作职责：
负责办公软件WPS Office客户端相关功能开发；
岗位要求：
1.二年以上相关工作经验，精通C++，理解面向对象思想，熟练使用标准库；
2.了解编译器原理，从事或研究过编译器开发者优先考虑；
3.熟悉常用数据结构与算法；
4.熟悉COM原理；
5.熟悉Windows或Linux平台开发。
